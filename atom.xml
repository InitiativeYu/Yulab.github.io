<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>INITIATIVEYU</title>
  
  
  <link href="http://localhost:4000/InitiativeYu.github.io/atom.xml" rel="self"/>
  
  <link href="http://localhost:4000/InitiativeYu.github.io/"/>
  <updated>2021-03-02T11:32:08.902Z</updated>
  <id>http://localhost:4000/InitiativeYu.github.io/</id>
  
  <author>
    <name>InitiativeYu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SpringBoot笔记</title>
    <link href="http://localhost:4000/InitiativeYu.github.io/2021/03/02/SpringBoot%E7%AC%94%E8%AE%B0/"/>
    <id>http://localhost:4000/InitiativeYu.github.io/2021/03/02/SpringBoot%E7%AC%94%E8%AE%B0/</id>
    <published>2021-03-02T08:49:19.094Z</published>
    <updated>2021-03-02T11:32:08.902Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot简介"><a href="#SpringBoot简介" class="headerlink" title="SpringBoot简介"></a>SpringBoot简介</h1><h2 id="回顾什么是Spring"><a href="#回顾什么是Spring" class="headerlink" title="回顾什么是Spring"></a>回顾什么是Spring</h2><p>Spring是一个开源框架，2003 年兴起的一个轻量级的Java 开发框架，作者：Rod Johnson  。</p><p><strong>Spring是为了解决企业级应用开发的复杂性而创建的，简化开发。</strong></p><h2 id="Spring是如何简化Java开发的"><a href="#Spring是如何简化Java开发的" class="headerlink" title="Spring是如何简化Java开发的"></a>Spring是如何简化Java开发的</h2><p>为了降低Java开发的复杂性，Spring采用了以下4种关键策略：</p><p>1、基于POJO的轻量级和最小侵入性编程，所有东西都是bean；</p><p>2、通过IOC，依赖注入（DI）和面向接口实现松耦合；</p><p>3、基于切面（AOP）和惯例进行声明式编程；</p><p>4、通过切面和模版减少样式代码，RedisTemplate，xxxTemplate；</p><h2 id="什么是SpringBoot"><a href="#什么是SpringBoot" class="headerlink" title="什么是SpringBoot"></a>什么是SpringBoot</h2><p>学过javaweb的同学就知道，开发一个web应用，从最初开始接触Servlet结合Tomcat, 跑出一个Hello Wolrld程序，是要经历特别多的步骤；后来就用了框架Struts，再后来是SpringMVC，到了现在的SpringBoot，过一两年又会有其他web框架出现；你们有经历过框架不断的演进，然后自己开发项目所有的技术也在不断的变化、改造吗？建议都可以去经历一遍；</p><p>言归正传，什么是SpringBoot呢，就是一个javaweb的开发框架，和SpringMVC类似，对比其他javaweb框架的好处，官方说是简化开发，约定大于配置，  you can “just run”，能迅速的开发web应用，几行代码开发一个http接口。</p><p>所有的技术框架的发展似乎都遵循了一条主线规律：从一个复杂应用场景 衍生 一种规范框架，人们只需要进行各种配置而不需要自己去实现它，这时候强大的配置功能成了优点；发展到一定程度之后，人们根据实际生产应用情况，选取其中实用功能和设计精华，重构出一些轻量级的框架；之后为了提高开发效率，嫌弃原先的各类配置过于麻烦，于是开始提倡“约定大于配置”，进而衍生出一些一站式的解决方案。</p><p>是的这就是Java企业级应用-&gt;J2EE-&gt;spring-&gt;springboot的过程。</p><p>随着 Spring 不断的发展，涉及的领域越来越多，项目整合开发需要配合各种各样的文件，慢慢变得不那么易用简单，违背了最初的理念，甚至人称配置地狱。Spring Boot 正是在这样的一个背景下被抽象出来的开发框架，目的为了让大家更容易的使用 Spring 、更容易的集成各种常用的中间件、开源软件；</p><p>Spring Boot 基于 Spring 开发，Spirng Boot 本身并不提供 Spring 框架的核心特性以及扩展功能，只是用于快速、敏捷地开发新一代基于 Spring 框架的应用程序。也就是说，它并不是用来替代 Spring 的解决方案，而是和 Spring 框架紧密结合用于提升 Spring 开发者体验的工具。Spring Boot 以<strong>约定大于配置的核心思想</strong>，默认帮我们进行了很多设置，多数 Spring Boot 应用只需要很少的 Spring 配置。同时它集成了大量常用的第三方库配置（例如 Redis、MongoDB、Jpa、RabbitMQ、Quartz 等等），Spring Boot 应用中这些第三方库几乎可以零配置的开箱即用。</p><p>简单来说就是SpringBoot其实不是什么新的框架，它默认配置了很多框架的使用方式，就像maven整合了所有的jar包，spring boot整合了所有的框架 。Spring Boot 出生名门，从一开始就站在一个比较高的起点，又经过这几年的发展，生态足够完善，Spring Boot 已经当之无愧成为 Java 领域最热门的技术。</p><p><strong>Spring Boot的主要优点：</strong></p><ul><li>为所有Spring开发者更快的入门</li><li><strong>开箱即用</strong>，提供各种默认配置来简化项目配置</li><li>内嵌式容器简化Web项目</li><li>没有冗余代码生成和XML配置的要求</li></ul><p>真的很爽，我们快速去体验开发个接口的感觉吧！</p><h1 id="Hello，World"><a href="#Hello，World" class="headerlink" title="Hello，World"></a>Hello，World</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>我们将学习如何快速的创建一个Spring Boot应用，并且实现一个简单的Http请求处理。通过这个例子对Spring Boot有一个初步的了解，并体验其结构简单、开发快速的特性。</p><p>我的环境准备：</p><ul><li>java version “1.8.0_181”</li><li>Maven-3.6.1</li><li>SpringBoot 2.x 最新版</li></ul><p>开发工具：</p><ul><li>IDEA</li></ul><h2 id="创建基础项目说明"><a href="#创建基础项目说明" class="headerlink" title="创建基础项目说明"></a>创建基础项目说明</h2><p>Spring官方提供了非常方便的工具让我们快速构建应用</p><p>Spring Initializr：<a href="https://start.spring.io/">https://start.spring.io/</a></p><p><strong>项目创建方式一：</strong>使用Spring Initializr 的 Web页面创建项目</p><p>1、打开  <a href="https://start.spring.io/">https://start.spring.io/</a></p><p>2、填写项目信息</p><p>3、点击”Generate Project“按钮生成项目；下载此项目</p><p>4、解压项目包，并用IDEA以Maven项目导入，一路下一步即可，直到项目导入完毕。</p><p>5、如果是第一次使用，可能速度会比较慢，包比较多、需要耐心等待一切就绪。</p><p><strong>项目创建方式二：</strong>使用 IDEA 直接创建项目</p><p>1、创建一个新项目</p><p>2、选择spring initalizr ， 可以看到默认就是去官网的快速构建工具那里实现</p><p>3、填写项目信息</p><p>4、选择初始化的组件（初学勾选 Web 即可）</p><p>5、填写项目路径</p><p>6、等待项目构建成功</p><p><strong>项目结构分析：</strong></p><p>通过上面步骤完成了基础项目的创建。就会自动生成以下文件。</p><p>1、程序的主启动类</p><p>2、一个 application.properties 配置文件</p><p>3、一个 测试类</p><p>4、一个 pom.xml</p><h2 id="pom-xml-分析"><a href="#pom-xml-分析" class="headerlink" title="pom.xml 分析"></a>pom.xml 分析</h2><p>打开pom.xml，看看Spring Boot项目的依赖：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&lt;!-- 父依赖 --&gt;&lt;parent&gt;    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;    &lt;version&gt;2.2.5.RELEASE&lt;&#x2F;version&gt;    &lt;relativePath&#x2F;&gt;&lt;&#x2F;parent&gt;&lt;dependencies&gt;    &lt;!-- web场景启动器 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;    &lt;&#x2F;dependency&gt;    &lt;!-- springboot单元测试 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;        &lt;scope&gt;test&lt;&#x2F;scope&gt;        &lt;!-- 剔除依赖 --&gt;        &lt;exclusions&gt;            &lt;exclusion&gt;                &lt;groupId&gt;org.junit.vintage&lt;&#x2F;groupId&gt;                &lt;artifactId&gt;junit-vintage-engine&lt;&#x2F;artifactId&gt;            &lt;&#x2F;exclusion&gt;        &lt;&#x2F;exclusions&gt;    &lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt;&lt;build&gt;    &lt;plugins&gt;        &lt;!-- 打包插件 --&gt;        &lt;plugin&gt;            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;            &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;        &lt;&#x2F;plugin&gt;    &lt;&#x2F;plugins&gt;&lt;&#x2F;build&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h2 id="编写一个http接口"><a href="#编写一个http接口" class="headerlink" title="编写一个http接口"></a>编写一个http接口</h2><p>1、在主程序的同级目录下，新建一个controller包，一定要在同级目录下，否则识别不到</p><p>2、在包中新建一个HelloController类</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RestControllerpublic class HelloController &#123;    @RequestMapping(&quot;&#x2F;hello&quot;)    public String hello() &#123;        return &quot;Hello World&quot;;    &#125;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>3、编写完毕后，从主程序启动项目，浏览器发起请求，看页面返回；控制台输出了 Tomcat 访问的端口号！</p><p><img src="https://img2020.cnblogs.com/i-beta/1418974/202003/1418974-20200309121116815-130096283.png" alt="img"></p><p>简单几步，就完成了一个web接口的开发，SpringBoot就是这么简单。所以我们常用它来建立我们的微服务项目！</p><h2 id="将项目打成jar包，点击-maven的-package"><a href="#将项目打成jar包，点击-maven的-package" class="headerlink" title="将项目打成jar包，点击 maven的 package"></a>将项目打成jar包，点击 maven的 package</h2><p> <img src="https://img2020.cnblogs.com/i-beta/1418974/202003/1418974-20200309121140605-880182525.png" alt="img"></p><p> 如果遇到以上错误，可以配置打包时 跳过项目运行测试用例</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&lt;!--    在工作中,很多情况下我们打包是不想执行测试用例的    可能是测试用例不完事,或是测试用例会影响数据库数据    跳过测试用例执    --&gt;&lt;plugin&gt;    &lt;groupId&gt;org.apache.maven.plugins&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;maven-surefire-plugin&lt;&#x2F;artifactId&gt;    &lt;configuration&gt;        &lt;!--跳过项目运行测试用例--&gt;        &lt;skipTests&gt;true&lt;&#x2F;skipTests&gt;    &lt;&#x2F;configuration&gt;&lt;&#x2F;plugin&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>如果打包成功，则会在target目录下生成一个 jar 包</p><p> <img src="https://img2020.cnblogs.com/i-beta/1418974/202003/1418974-20200309121222426-2103556472.png" alt="img"></p><p>打成了jar包后，就可以在任何地方运行了！OK</p><h2 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a><strong>彩蛋</strong></h2><p>如何更改启动时显示的字符拼成的字母，SpringBoot呢？也就是 banner 图案；</p><p>只需一步：到项目下的 resources 目录下新建一个banner.txt 即可。</p><p>图案可以到：<a href="https://www.bootschool.net/ascii">https://www.bootschool.net/ascii</a> 这个网站生成，然后拷贝到文件中即可！</p><p> <img src="https://img2020.cnblogs.com/i-beta/1418974/202003/1418974-20200309121253129-1107327471.png" alt="img"></p><h1 id="运行原理探究"><a href="#运行原理探究" class="headerlink" title="运行原理探究"></a>运行原理探究</h1><p>我们之前写的HelloSpringBoot，到底是怎么运行的呢，Maven项目，我们一般从pom.xml文件探究起；</p><h1 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a><strong>pom.xml</strong></h1><h2 id="父依赖"><a href="#父依赖" class="headerlink" title="父依赖"></a>父依赖</h2><p>其中它主要是依赖一个父项目，主要是管理项目的资源过滤及插件！</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&lt;parent&gt;    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;    &lt;version&gt;2.2.5.RELEASE&lt;&#x2F;version&gt;    &lt;relativePath&#x2F;&gt; &lt;!-- lookup parent from repository --&gt;&lt;&#x2F;parent&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>点进去，发现还有一个父依赖</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&lt;parent&gt;    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-boot-dependencies&lt;&#x2F;artifactId&gt;    &lt;version&gt;2.2.5.RELEASE&lt;&#x2F;version&gt;    &lt;relativePath&gt;..&#x2F;..&#x2F;spring-boot-dependencies&lt;&#x2F;relativePath&gt;&lt;&#x2F;parent&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>这里才是真正管理SpringBoot应用里面所有依赖版本的地方，SpringBoot的版本控制中心；</p><p><strong>以后我们导入依赖默认是不需要写版本；但是如果导入的包没有在依赖中管理着就需要手动配置版本了；</strong></p><h2 id="启动器-spring-boot-starter"><a href="#启动器-spring-boot-starter" class="headerlink" title="启动器 spring-boot-starter"></a>启动器 spring-boot-starter</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>springboot-boot-starter-xxx</strong>：就是spring-boot的场景启动器</p><p><strong>spring-boot-starter-web</strong>：帮我们导入了web模块正常运行所依赖的组件；</p><p>SpringBoot将所有的功能场景都抽取出来，做成一个个的starter （启动器），只需要在项目中引入这些starter即可，所有相关的依赖都会导入进来 ， 我们要用什么功能就导入什么样的场景启动器即可 ；我们未来也可以自己自定义 starter；</p><h1 id="主启动类"><a href="#主启动类" class="headerlink" title="主启动类"></a><strong>主启动类</strong></h1><p>分析完了 pom.xml 来看看这个启动类</p><h2 id="默认的主启动类"><a href="#默认的主启动类" class="headerlink" title="默认的主启动类"></a>默认的主启动类</h2><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;@SpringBootApplication 来标注一个主程序类&#x2F;&#x2F;说明这是一个Spring Boot应用@SpringBootApplicationpublic class SpringbootApplication &#123;   public static void main(String[] args) &#123;     &#x2F;&#x2F;以为是启动了一个方法，没想到启动了一个服务      SpringApplication.run(SpringbootApplication.class, args);   &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>但是<strong>一个简单的启动类并不简单！</strong>我们来分析一下这些注解都干了什么</p><h2 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</h2><p>作用：标注在某个类上说明这个类是SpringBoot的主配置类 ， SpringBoot就应该运行这个类的main方法来启动SpringBoot应用；</p><p>进入这个注解：可以看到上面还有很多其他注解！</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(    excludeFilters &#x3D; &#123;@Filter(    type &#x3D; FilterType.CUSTOM,    classes &#x3D; &#123;TypeExcludeFilter.class&#125;), @Filter(    type &#x3D; FilterType.CUSTOM,    classes &#x3D; &#123;AutoConfigurationExcludeFilter.class&#125;)&#125;)public @interface SpringBootApplication &#123;    &#x2F;&#x2F; ......&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h2 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h2><p>这个注解在Spring中很重要 ,它对应XML配置中的元素。</p><p>作用：自动扫描并加载符合条件的组件或者bean ， 将这个bean定义加载到IOC容器中</p><h2 id="SpringBootConfiguration"><a href="#SpringBootConfiguration" class="headerlink" title="@SpringBootConfiguration"></a>@SpringBootConfiguration</h2><p>作用：SpringBoot的配置类 ，标注在某个类上 ， 表示这是一个SpringBoot的配置类；</p><p>我们继续进去这个注解查看</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 点进去得到下面的 @Component@Configurationpublic @interface SpringBootConfiguration &#123;&#125;@Componentpublic @interface Configuration &#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>这里的 @Configuration，说明这是一个配置类 ，配置类就是对应Spring的xml 配置文件；</p><p>里面的 @Component 这就说明，启动类本身也是Spring中的一个组件而已，负责启动应用！</p><p>我们回到 SpringBootApplication 注解中继续看。</p><h2 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h2><p><strong>@EnableAutoConfiguration ：开启自动配置功能</strong></p><p>以前我们需要自己配置的东西，而现在SpringBoot可以自动帮我们配置 ；@EnableAutoConfiguration告诉SpringBoot开启自动配置功能，这样自动配置才能生效；</p><p>点进注解接续查看：</p><p><strong>@AutoConfigurationPackage ：自动配置包</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Import(&#123;Registrar.class&#125;)public @interface AutoConfigurationPackage &#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>@import</strong> ：Spring底层注解@import ， 给容器中导入一个组件</p><p>Registrar.class 作用：将主启动类的所在包及包下面所有子包里面的所有组件扫描到Spring容器 ；</p><p>这个分析完了，退到上一步，继续看</p><p><strong>@Import({AutoConfigurationImportSelector.class}) ：给容器导入组件 ；</strong></p><p>AutoConfigurationImportSelector ：自动配置导入选择器，那么它会导入哪些组件的选择器呢？我们点击去这个类看源码：</p><p>1、这个类中有一个这样的方法</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 获得候选的配置protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) &#123;    &#x2F;&#x2F;这里的getSpringFactoriesLoaderFactoryClass（）方法    &#x2F;&#x2F;返回的就是我们最开始看的启动自动导入配置文件的注解类；EnableAutoConfiguration    List&lt;String&gt; configurations &#x3D; SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader());    Assert.notEmpty(configurations, &quot;No auto configuration classes found in META-INF&#x2F;spring.factories. If you are using a custom packaging, make sure that file is correct.&quot;);    return configurations;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>2、这个方法又调用了  SpringFactoriesLoader 类的静态方法！我们进入SpringFactoriesLoader类loadFactoryNames() 方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryClass, @Nullable ClassLoader classLoader) &#123;    String factoryClassName &#x3D; factoryClass.getName();    &#x2F;&#x2F;这里它又调用了 loadSpringFactories 方法    return (List)loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList());&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3、我们继续点击查看 loadSpringFactories 方法</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">private static Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(@Nullable ClassLoader classLoader) &#123;    &#x2F;&#x2F;获得classLoader ， 我们返回可以看到这里得到的就是EnableAutoConfiguration标注的类本身    MultiValueMap&lt;String, String&gt; result &#x3D; (MultiValueMap)cache.get(classLoader);    if (result !&#x3D; null) &#123;        return result;    &#125; else &#123;        try &#123;            &#x2F;&#x2F;去获取一个资源 &quot;META-INF&#x2F;spring.factories&quot;            Enumeration&lt;URL&gt; urls &#x3D; classLoader !&#x3D; null ? classLoader.getResources(&quot;META-INF&#x2F;spring.factories&quot;) : ClassLoader.getSystemResources(&quot;META-INF&#x2F;spring.factories&quot;);            LinkedMultiValueMap result &#x3D; new LinkedMultiValueMap();            &#x2F;&#x2F;将读取到的资源遍历，封装成为一个Properties            while(urls.hasMoreElements()) &#123;                URL url &#x3D; (URL)urls.nextElement();                UrlResource resource &#x3D; new UrlResource(url);                Properties properties &#x3D; PropertiesLoaderUtils.loadProperties(resource);                Iterator var6 &#x3D; properties.entrySet().iterator();                while(var6.hasNext()) &#123;                    Entry&lt;?, ?&gt; entry &#x3D; (Entry)var6.next();                    String factoryClassName &#x3D; ((String)entry.getKey()).trim();                    String[] var9 &#x3D; StringUtils.commaDelimitedListToStringArray((String)entry.getValue());                    int var10 &#x3D; var9.length;                    for(int var11 &#x3D; 0; var11 &lt; var10; ++var11) &#123;                        String factoryName &#x3D; var9[var11];                        result.add(factoryClassName, factoryName.trim());                    &#125;                &#125;            &#125;            cache.put(classLoader, result);            return result;        &#125; catch (IOException var13) &#123;            throw new IllegalArgumentException(&quot;Unable to load factories from location [META-INF&#x2F;spring.factories]&quot;, var13);        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>4、发现一个多次出现的文件：spring.factories，全局搜索它</p><h2 id="spring-factories"><a href="#spring-factories" class="headerlink" title="spring.factories"></a>spring.factories</h2><p>我们根据源头打开spring.factories ， 看到了很多自动配置的文件；这就是自动配置根源所在！</p><p><img src="https://img2020.cnblogs.com/i-beta/1418974/202003/1418974-20200309184240867-805619137.png" alt="img"></p><p><strong>WebMvcAutoConfiguration</strong></p><p>我们在上面的自动配置类随便找一个打开看看，比如 ：WebMvcAutoConfiguration</p><p><img src="https://img2020.cnblogs.com/i-beta/1418974/202003/1418974-20200309184256364-753864375.png" alt="img"></p><p>可以看到这些一个个的都是JavaConfig配置类，而且都注入了一些Bean，可以找一些自己认识的类，看着熟悉一下！</p><p>所以，自动配置真正实现是从classpath中搜寻所有的META-INF/spring.factories配置文件 ，并将其中对应的 org.springframework.boot.autoconfigure. 包下的配置项，通过反射实例化为对应标注了 @Configuration的JavaConfig形式的IOC容器配置类 ， 然后将这些都汇总成为一个实例并加载到IOC容器中。</p><p><strong>结论：</strong></p><ol><li>SpringBoot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值</li><li>将这些值作为自动配置类导入容器 ， 自动配置类就生效 ， 帮我们进行自动配置工作；</li><li>整个J2EE的整体解决方案和自动配置都在springboot-autoconfigure的jar包中；</li><li>它会给容器中导入非常多的自动配置类 （xxxAutoConfiguration）, 就是给容器中导入这个场景需要的所有组件 ， 并配置好这些组件 ；</li><li>有了自动配置类 ， 免去了我们手动编写配置注入功能组件等的工作；</li></ol><p><strong>现在大家应该大概的了解了下，SpringBoot的运行原理，后面我们还会深化一次！</strong></p><h1 id="SpringApplication"><a href="#SpringApplication" class="headerlink" title="SpringApplication"></a><strong>SpringApplication</strong></h1><h2 id="不简单的方法"><a href="#不简单的方法" class="headerlink" title="不简单的方法"></a>不简单的方法</h2><p>我最初以为就是运行了一个main方法，没想到却开启了一个服务；</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootApplicationpublic class SpringbootApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(SpringbootApplication.class, args);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><strong>SpringApplication.run分析</strong></p><p>分析该方法主要分两部分，一部分是SpringApplication的实例化，二是run方法的执行；</p><h2 id="SpringApplication-1"><a href="#SpringApplication-1" class="headerlink" title="SpringApplication"></a>SpringApplication</h2><p><strong>这个类主要做了以下四件事情：</strong></p><p>1、推断应用的类型是普通的项目还是Web项目</p><p>2、查找并加载所有可用初始化器 ， 设置到initializers属性中</p><p>3、找出所有的应用程序监听器，设置到listeners属性中</p><p>4、推断并设置main方法的定义类，找到运行的主类</p><p>查看构造器：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public SpringApplication(ResourceLoader resourceLoader, Class... primarySources) &#123;    &#x2F;&#x2F; ......    this.webApplicationType &#x3D; WebApplicationType.deduceFromClasspath();    this.setInitializers(this.getSpringFactoriesInstances();    this.setListeners(this.getSpringFactoriesInstances(ApplicationListener.class));    this.mainApplicationClass &#x3D; this.deduceMainApplicationClass();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h2 id="run方法流程分析"><a href="#run方法流程分析" class="headerlink" title="run方法流程分析"></a>run方法流程分析</h2><p><img src="https://img2020.cnblogs.com/i-beta/1418974/202003/1418974-20200309184347408-1065424525.png" alt="img"></p><p> 跟着源码和这幅图就可以一探究竟了！</p><h1 id="yaml语法学习"><a href="#yaml语法学习" class="headerlink" title="yaml语法学习"></a>yaml语法学习</h1><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>SpringBoot使用一个全局的配置文件 ， 配置文件名称是固定的</p><ul><li><p>application.properties</p></li><li><ul><li>语法结构 ：key=value</li></ul></li><li><p>application.yml</p></li><li><ul><li>语法结构 ：key：空格 value</li></ul></li></ul><p><strong>配置文件的作用 ：</strong>修改SpringBoot自动配置的默认值，因为SpringBoot在底层都给我们自动配置好了；</p><p>比如我们可以在配置文件中修改Tomcat 默认启动的端口号！测试一下！</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">server.port&#x3D;8081<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="yaml概述"><a href="#yaml概述" class="headerlink" title="yaml概述"></a>yaml概述</h2><p>YAML是 “YAML Ain’t a Markup Language” （YAML不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是：”Yet Another Markup Language”（仍是一种标记语言）</p><p><strong>这种语言以数据**</strong>作**<strong>为中心，而不是以标记语言为重点！</strong></p><p>以前的配置文件，大多数都是使用xml来配置；比如一个简单的端口配置，我们来对比下yaml和xml</p><p>传统xml配置：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&lt;server&gt;    &lt;port&gt;8081&lt;port&gt;&lt;&#x2F;server&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>yaml配置：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">server：  prot: 8080<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="yaml基础语法"><a href="#yaml基础语法" class="headerlink" title="yaml基础语法"></a>yaml基础语法</h2><p>说明：语法要求严格！</p><p>1、空格不能省略</p><p>2、以缩进来控制层级关系，只要是左边对齐的一列数据都是同一个层级的。</p><p>3、属性和值的大小写都是十分敏感的。</p><p><strong>字面量：普通的值  [ 数字，布尔值，字符串  ]</strong></p><p>字面量直接写在后面就可以 ， 字符串默认不用加上双引号或者单引号；</p><pre class="line-numbers language-java'" data-language="java'"><code class="language-java'">k: v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意：</p><ul><li><p>“ ” 双引号，不会转义字符串里面的特殊字符 ， 特殊字符会作为本身想表示的意思；</p><p>比如 ：name: “kuang \n shen”  输出 ：kuang  换行  shen</p></li><li><p>‘’ 单引号，会转义特殊字符 ， 特殊字符最终会变成和普通字符一样输出</p><p>比如 ：name: ‘kuang \n shen’  输出 ：kuang  \n  shen</p></li></ul><p><strong>对象、Map（键值对）</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">#对象、Map格式k:     v1:    v2:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在下一行来写对象的属性和值得关系，注意缩进；比如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">student:    name: qinjiang    age: 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>行内写法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">student: &#123;name: qinjiang,age: 3&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>数组（ List、set ）</strong></p><p>用 - 值表示数组中的一个元素,比如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">pets: - cat - dog - pig<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>行内写法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">pets: [cat,dog,pig]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>修改SpringBoot的默认端口号</strong></p><p>配置文件中添加，端口号的参数，就可以切换端口；</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">server:  port: 8082<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="注入配置文件"><a href="#注入配置文件" class="headerlink" title="注入配置文件"></a>注入配置文件</h1><p>yaml文件更强大的地方在于，他可以给我们的实体类直接注入匹配值！</p><h2 id="yaml注入配置文件"><a href="#yaml注入配置文件" class="headerlink" title="yaml注入配置文件"></a>yaml注入配置文件</h2><p>1、在springboot项目中的resources目录下新建一个文件 application.yml</p><p>2、编写一个实体类 Dog；</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.kuang.springboot.pojo;@Component  &#x2F;&#x2F;注册bean到容器中public class Dog &#123;    private String name;    private Integer age;        &#x2F;&#x2F;有参无参构造、get、set方法、toString()方法  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>3、思考，我们原来是如何给bean注入属性值的！@Value，给狗狗类测试一下：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Component &#x2F;&#x2F;注册beanpublic class Dog &#123;    @Value(&quot;阿黄&quot;)    private String name;    @Value(&quot;18&quot;)    private Integer age;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>4、在SpringBoot的测试类下注入狗狗输出一下；</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootTestclass DemoApplicationTests &#123;    @Autowired &#x2F;&#x2F;将狗狗自动注入进来    Dog dog;    @Test    public void contextLoads() &#123;        System.out.println(dog); &#x2F;&#x2F;打印看下狗狗对象    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>结果成功输出，@Value注入成功，这是我们原来的办法对吧。</p><p><img src="https://img2020.cnblogs.com/i-beta/1418974/202003/1418974-20200310171619161-361814123.png" alt="img"></p><p> 5、我们在编写一个复杂一点的实体类：Person 类</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Component &#x2F;&#x2F;注册bean到容器中public class Person &#123;    private String name;    private Integer age;    private Boolean happy;    private Date birth;    private Map&lt;String,Object&gt; maps;    private List&lt;Object&gt; lists;    private Dog dog;        &#x2F;&#x2F;有参无参构造、get、set方法、toString()方法  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>6、我们来使用yaml配置的方式进行注入，大家写的时候注意区别和优势，我们编写一个yaml配置！</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">person:  name: qinjiang  age: 3  happy: false  birth: 2000&#x2F;01&#x2F;01  maps: &#123;k1: v1,k2: v2&#125;  lists:   - code   - girl   - music  dog:    name: 旺财    age: 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>7、我们刚才已经把person这个对象的所有值都写好了，我们现在来注入到我们的类中！</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;*@ConfigurationProperties作用：将配置文件中配置的每一个属性的值，映射到这个组件中；告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定参数 prefix &#x3D; “person” : 将配置文件中的person下面的所有属性一一对应*&#x2F;@Component &#x2F;&#x2F;注册bean@ConfigurationProperties(prefix &#x3D; &quot;person&quot;)public class Person &#123;    private String name;    private Integer age;    private Boolean happy;    private Date birth;    private Map&lt;String,Object&gt; maps;    private List&lt;Object&gt; lists;    private Dog dog;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>8、IDEA 提示，springboot配置注解处理器没有找到，让我们看文档，我们可以查看文档，找到一个依赖！</p><p><img src="https://img2020.cnblogs.com/i-beta/1418974/202003/1418974-20200310171716557-1171634646.png" alt="img"></p><p> <img src="https://img2020.cnblogs.com/i-beta/1418974/202003/1418974-20200310171732726-836990442.png" alt="img"></p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&lt;!-- 导入配置文件处理器，配置文件进行绑定就会有提示，需要重启 --&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;  &lt;artifactId&gt;spring-boot-configuration-processor&lt;&#x2F;artifactId&gt;  &lt;optional&gt;true&lt;&#x2F;optional&gt;&lt;&#x2F;dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>9、确认以上配置都OK之后，我们去测试类中测试一下：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootTestclass DemoApplicationTests &#123;    @Autowired    Person person; &#x2F;&#x2F;将person自动注入进来    @Test    public void contextLoads() &#123;        System.out.println(person); &#x2F;&#x2F;打印person信息    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><strong>yaml配置注入到实体类完全OK！</strong></p><p>课堂测试：</p><p>1、将配置文件的key 值 和 属性的值设置为不一样，则结果输出为null，注入失败</p><p>2、在配置一个person2，然后将 @ConfigurationProperties(prefix = “person2”) 指向我们的person2；</p><h2 id="加载指定的配置文件"><a href="#加载指定的配置文件" class="headerlink" title="加载指定的配置文件"></a>加载指定的配置文件</h2><p><strong>@PropertySource ：</strong>加载指定的配置文件；</p><p><strong>@configurationProperties</strong>：默认从全局配置文件中获取值；</p><p>1、我们去在resources目录下新建一个<strong>person.properties</strong>文件</p><pre class="line-numbers language-none"><code class="language-none">name&#x3D;kuangshen<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2、然后在我们的代码中指定加载person.properties文件</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@PropertySource(value &#x3D; &quot;classpath:person.properties&quot;)@Component &#x2F;&#x2F;注册beanpublic class Person &#123;    @Value(&quot;$&#123;name&#125;&quot;)    private String name;    ......  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>3、再次输出测试一下：指定配置文件绑定成功！</p><p><img src="https://img2020.cnblogs.com/i-beta/1418974/202003/1418974-20200310171849223-598564726.png" alt="img"></p><h2 id="配置文件占位符"><a href="#配置文件占位符" class="headerlink" title="配置文件占位符"></a>配置文件占位符</h2><p>配置文件还可以编写占位符生成随机数</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">person:    name: qinjiang$&#123;random.uuid&#125; # 随机uuid    age: $&#123;random.int&#125;  # 随机int    happy: false    birth: 2000&#x2F;01&#x2F;01    maps: &#123;k1: v1,k2: v2&#125;    lists:      - code      - girl      - music    dog:      name: $&#123;person.hello:other&#125;_旺财      age: 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h2 id="回顾properties配置"><a href="#回顾properties配置" class="headerlink" title="回顾properties配置"></a>回顾properties配置</h2><p>我们上面采用的yaml方法都是最简单的方式，开发中最常用的；也是springboot所推荐的！那我们来唠唠其他的实现方式，道理都是相同的；写还是那样写；配置文件除了yml还有我们之前常用的properties ， 我们没有讲，我们来唠唠！</p><p>【注意】properties配置文件在写中文的时候，会有乱码 ， 我们需要去IDEA中设置编码格式为UTF-8；</p><p>settings–&gt;FileEncodings 中配置；</p><p><img src="https://img2020.cnblogs.com/i-beta/1418974/202003/1418974-20200310171916773-140372588.png" alt="img"></p><p><strong>测试步骤：</strong></p><p>1、新建一个实体类User</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Component &#x2F;&#x2F;注册beanpublic class User &#123;    private String name;    private int age;    private String sex;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>2、编辑配置文件 user.properties</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">user1.name&#x3D;kuangshenuser1.age&#x3D;18user1.sex&#x3D;男<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>3、我们在User类上使用@Value来进行注入！</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Component &#x2F;&#x2F;注册bean@PropertySource(value &#x3D; &quot;classpath:user.properties&quot;)public class User &#123;    &#x2F;&#x2F;直接使用@value    @Value(&quot;$&#123;user.name&#125;&quot;) &#x2F;&#x2F;从配置文件中取值    private String name;    @Value(&quot;#&#123;9*2&#125;&quot;)  &#x2F;&#x2F; #&#123;SPEL&#125; Spring表达式    private int age;    @Value(&quot;男&quot;)  &#x2F;&#x2F; 字面量    private String sex;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>4、Springboot测试</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootTestclass DemoApplicationTests &#123;    @Autowired    User user;    @Test    public void contextLoads() &#123;        System.out.println(user);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>结果正常输出：</p><p><img src="https://img2020.cnblogs.com/i-beta/1418974/202003/1418974-20200310172007936-1863549353.png" alt="img"></p><h2 id="对比小结"><a href="#对比小结" class="headerlink" title="对比小结"></a>对比小结</h2><p>@Value这个使用起来并不友好！我们需要为每个属性单独注解赋值，比较麻烦；我们来看个功能对比图</p><p> <img src="https://img2020.cnblogs.com/i-beta/1418974/202003/1418974-20200310172022780-374285033.png" alt="img"></p><p>1、@ConfigurationProperties只需要写一次即可 ， @Value则需要每个字段都添加</p><p>2、松散绑定：这个什么意思呢? 比如我的yml中写的last-name，这个和lastName是一样的， - 后面跟着的字母默认是大写的。这就是松散绑定。可以测试一下</p><p>3、JSR303数据校验 ， 这个就是我们可以在字段是增加一层过滤器验证 ， 可以保证数据的合法性</p><p>4、复杂类型封装，yml中可以封装对象 ， 使用value就不支持</p><p><strong>结论：</strong></p><p>配置yml和配置properties都可以获取到值 ， 强烈推荐 yml；</p><p>如果我们在某个业务中，只需要获取配置文件中的某个值，可以使用一下 @value；</p><p>如果说，我们专门编写了一个JavaBean来和配置文件进行一一映射，就直接@configurationProperties，不要犹豫！</p><blockquote></blockquote><h1 id="JSR303数据校验"><a href="#JSR303数据校验" class="headerlink" title="JSR303数据校验"></a>JSR303数据校验</h1><h2 id="先看看如何使用"><a href="#先看看如何使用" class="headerlink" title="先看看如何使用"></a>先看看如何使用</h2><p>Springboot中可以用@validated来校验数据，如果数据异常则会统一抛出异常，方便异常中心统一处理。我们这里来写个注解让我们的name只能支持Email格式；</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Component &#x2F;&#x2F;注册bean@ConfigurationProperties(prefix &#x3D; &quot;person&quot;)@Validated  &#x2F;&#x2F;数据校验public class Person &#123;    @Email(message&#x3D;&quot;邮箱格式错误&quot;) &#x2F;&#x2F;name必须是邮箱格式    private String name;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p> 运行结果 ：default message [不是一个合法的电子邮件地址];</p><p> <img src="https://img2020.cnblogs.com/i-beta/1418974/202003/1418974-20200311124206128-825984089.png" alt="img"></p><p> <strong>使用数据校验，可以保证数据的正确性；</strong></p><h2 id="常见参数"><a href="#常见参数" class="headerlink" title="常见参数"></a>常见参数</h2><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@NotNull(message&#x3D;&quot;名字不能为空&quot;)private String userName;@Max(value&#x3D;120,message&#x3D;&quot;年龄最大不能查过120&quot;)private int age;@Email(message&#x3D;&quot;邮箱格式错误&quot;)private String email;空检查@Null       验证对象是否为null@NotNull    验证对象是否不为null, 无法查检长度为0的字符串@NotBlank   检查约束字符串是不是Null还有被Trim的长度是否大于0,只对字符串,且会去掉前后空格.@NotEmpty   检查约束元素是否为NULL或者是EMPTY.    Booelan检查@AssertTrue     验证 Boolean 对象是否为 true  @AssertFalse    验证 Boolean 对象是否为 false      长度检查@Size(min&#x3D;, max&#x3D;) 验证对象（Array,Collection,Map,String）长度是否在给定的范围之内  @Length(min&#x3D;, max&#x3D;) string is between min and max included.日期检查@Past       验证 Date 和 Calendar 对象是否在当前时间之前  @Future     验证 Date 和 Calendar 对象是否在当前时间之后  @Pattern    验证 String 对象是否符合正则表达式的规则.......等等除此以外，我们还可以自定义一些数据校验规则<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h1 id="多环境切换"><a href="#多环境切换" class="headerlink" title="多环境切换"></a>多环境切换</h1><p>profile是Spring对不同环境提供不同配置功能的支持，可以通过激活不同的环境版本，实现快速切换环境；</p><h2 id="配置文件-1"><a href="#配置文件-1" class="headerlink" title="配置文件"></a>配置文件</h2><p>我们在主配置文件编写的时候，文件名可以是 application-{profile}.properties/yml , 用来指定多个环境版本；</p><p><strong>例如：</strong></p><p>application-test.properties 代表测试环境配置</p><p>application-dev.properties 代表开发环境配置</p><p>但是Springboot并不会直接启动这些配置文件，它<strong>默认使用application.properties主配置文件</strong>；</p><p>我们需要通过一个配置来选择需要激活的环境：</p><pre class="line-numbers language-none"><code class="language-none">#比如在配置文件中指定使用dev环境，我们可以通过设置不同的端口号进行测试；#我们启动SpringBoot，就可以看到已经切换到dev下的配置了；spring.profiles.active&#x3D;dev<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="yaml的多文档块"><a href="#yaml的多文档块" class="headerlink" title="yaml的多文档块"></a>yaml的多文档块</h2><p>和properties配置文件中一样，但是使用yml去实现不需要创建多个配置文件，更加方便了 !</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">server:  port: 8081#选择要激活那个环境块spring:  profiles:    active: prod---server:  port: 8083spring:  profiles: dev #配置环境的名称---server:  port: 8084spring:  profiles: prod  #配置环境的名称<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p><strong>注意：如果yml和properties同时都配置了端口，并且没有激活其他环境 ， 默认会使用properties配置文件的！</strong></p><h2 id="配置文件加载位置"><a href="#配置文件加载位置" class="headerlink" title="配置文件加载位置"></a>配置文件加载位置</h2><p><strong>外部加载配置文件的方式十分多，我们选择最常用的即可，在开发的资源文件中进行配置！</strong></p><p>官方外部配置文件说明参考文档</p><p><img src="https://img2020.cnblogs.com/i-beta/1418974/202003/1418974-20200311124351635-1979908122.png" alt="img"></p><p>springboot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件：</p><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">优先级1：项目路径下的config文件夹配置文件优先级2：项目路径下配置文件优先级3：资源路径下的config文件夹配置文件优先级4：资源路径下配置文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>优先级由高到底，高优先级的配置会覆盖低优先级的配置；</p><p><strong>SpringBoot会从这四个位置全部加载主配置文件；互补配置；</strong></p><p>我们在最低级的配置文件中设置一个项目访问路径的配置来测试互补问题；</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">配置项目的访问路径server.servlet.context-path&#x3D;&#x2F;kuang<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="拓展，运维小技巧"><a href="#拓展，运维小技巧" class="headerlink" title="拓展，运维小技巧"></a>拓展，运维小技巧</h2><p>指定位置加载配置文件</p><p>我们还可以通过spring.config.location来改变默认的配置文件位置</p><p>项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；这种情况，一般是后期运维做的多，相同配置，外部指定的配置文件优先级最高</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">java -jar spring-boot-config.jar --spring.config.location&#x3D;F:&#x2F;application.properties<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SpringBoot简介&quot;&gt;&lt;a href=&quot;#SpringBoot简介&quot; class=&quot;headerlink&quot; title=&quot;SpringBoot简介&quot;&gt;&lt;/a&gt;SpringBoot简介&lt;/h1&gt;&lt;h2 id=&quot;回顾什么是Spring&quot;&gt;&lt;a href=&quot;#回顾</summary>
      
    
    
    
    <category term="转载" scheme="http://localhost:4000/InitiativeYu.github.io/categories/%E8%BD%AC%E8%BD%BD/"/>
    
    
    <category term="Springboot" scheme="http://localhost:4000/InitiativeYu.github.io/tags/Springboot/"/>
    
  </entry>
  
  <entry>
    <title>IDEA下建VUE项目</title>
    <link href="http://localhost:4000/InitiativeYu.github.io/2021/02/22/IDEA%E4%B8%8B%E5%BB%BAVue%E9%A1%B9%E7%9B%AE/"/>
    <id>http://localhost:4000/InitiativeYu.github.io/2021/02/22/IDEA%E4%B8%8B%E5%BB%BAVue%E9%A1%B9%E7%9B%AE/</id>
    <published>2021-02-22T13:37:31.629Z</published>
    <updated>2021-03-02T08:52:54.761Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IDEA中从零开始创建Vue项目"><a href="#IDEA中从零开始创建Vue项目" class="headerlink" title="IDEA中从零开始创建Vue项目"></a>IDEA中从零开始创建Vue项目</h1><p>好久没学技术了，今天开始学习Vue,我用的是IDEA，所以第一步就是如何在IDEA中创建Vue项目。在此期间，也是遇到了不少的坑，好在找到了许多优质的文章，所以在这里整理、记录，并分享给大家。</p><h2 id="一、需要了解的基本知识"><a href="#一、需要了解的基本知识" class="headerlink" title="一、需要了解的基本知识"></a>一、需要了解的基本知识</h2><hr><ul><li><h3 id="node-js"><a href="#node-js" class="headerlink" title="node.js"></a>node.js</h3></li></ul><blockquote><p>Node.js是一个Javascript运行环境(runtime)，发布于2009年5月，由Ryan Dahl开发，实质是对Chrome V8引擎进行了封装。Node.js对一些特殊用例进行优化，提供替代的API，使得V8在非浏览器环境下运行得更好。V8引擎执行Javascript的速度非常快，性能非常好。 Node.js是一个基于Chrome JavaScript运行时建立的平台， 用于方便地搭建响应速度快、易于扩展的网络应用。Node.js 使用事件驱动， 非阻塞I/O模型而得以轻量和高效，非常适合在分布式设备上运行数据密集型的实时应用。总结一下，node,js提供了javascript在浏览器以外的一个执行环境，满足一些特定的场景需求。</p></blockquote><ul><li><h3 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h3></li></ul><blockquote><p>npm 是 nodejs 的包管理和分发工具。它可以让 javascript 开发者能够更加轻松的共享代码和共用代码片段，并且通过 npm 管理你分享的代码也很方便快捷和简单。通过npm可以更方便的引用和分析基于nodejs开发的类库和插件。</p></blockquote><ul><li><h3 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h3></li></ul><blockquote><p>WebPack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其打包为合适的格式以供浏览器使用。通过webpack可以把基于模块开发的前端工程代码打包成可以在浏览器使用的格式。</p></blockquote><ul><li><h3 id="vue2"><a href="#vue2" class="headerlink" title="vue2"></a>vue2</h3></li></ul><blockquote><p>是一套构建用户界面的渐进式框架。与其他重量级框架不同的是，Vue 采用自底向上增量开发的设计。Vue 的核心库只关注视图层，它不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与单文件系统和vue生态系统支持的库结合使用时，Vue 也完全能够为复杂的单页应用程序提供驱动。在开发中vue会把使用vue语法修饰的html标签与js对象进行绑定，从而使html值变化时可以同步修改js对象，js对象值变化时可以在页面暂时，使开发从复杂的document操作中解脱出来。</p></blockquote><ul><li><h3 id="iview"><a href="#iview" class="headerlink" title="iview"></a>iview</h3></li></ul><blockquote><p>一套基于 Vue.js 的高质量 UI 组件库，通过iveiw可以快速的开发出风格一致的前端界面。</p></blockquote><hr><h2 id="二、node-js安装"><a href="#二、node-js安装" class="headerlink" title="二、node.js安装"></a>二、node.js安装</h2><ul><li><h3 id="下载地址：https-nodejs-org-en-download-。"><a href="#下载地址：https-nodejs-org-en-download-。" class="headerlink" title="下载地址：https://nodejs.org/en/download/。"></a>下载地址：<a href="https://nodejs.org/en/download/%E3%80%82">https://nodejs.org/en/download/。</a></h3></li></ul><blockquote><p>下载完成后安装（直接按默认方式安装就行）</p></blockquote><blockquote><p>打开cmd 输入下面的命令查看是否成功安装<br> <code>node -v</code><br> <code>npm -v</code></p></blockquote><h2 id="三、搭建项目"><a href="#三、搭建项目" class="headerlink" title="三、搭建项目"></a>三、搭建项目</h2><h3 id="1-打开idea-新建项目"><a href="#1-打开idea-新建项目" class="headerlink" title="1  .打开idea,新建项目"></a>1  .打开idea,新建项目</h3><p> <strong>Create New Project &gt; Static Web&gt;填写project name和选择保存的工作空间&gt;Finish</strong></p><p>​                                      </p><h3 id="2-安装vue脚手架工具"><a href="#2-安装vue脚手架工具" class="headerlink" title="2.安装vue脚手架工具"></a>2.安装vue脚手架工具</h3><ul><li>首先安装npm的淘宝镜像(下载速度比较快)，打开idea的Terminal</li></ul><p>  输入以下的命令</p><blockquote><pre class="line-numbers language-none"><code class="language-none">npm i -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><h4 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h4><p>tips. (这是我添加的自己遇到的情况)</p><p><strong>我们在使用npm安装依赖的时候有时候会出现“’npm’ 不是内部或外部命令，也不是可运行的程序”的提示，一般都是因为环境变量没配好</strong></p><p>在安装nodejs时候，有时候我们会把它安装在D盘或别的盘时，经常会遇到npm环境变量没有配好，需要自己手动去配置。</p><p>解决方法：</p><p><strong>发现问题后，我们在环境变量中添加我们安装的npm命令行执行文件路径</strong> </p><p><strong>我的是安装在D:\Program Files\nodejs下（如下图）</strong></p><p><img src="https://img-blog.csdn.net/20180118131654313?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjk3MTI5OTU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p><p><strong>则添加此路径的环境变量，按下图步骤</strong></p><p><img src="https://img-blog.csdn.net/20180118131916846?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjk3MTI5OTU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p><p>配置完环境变量后，在doc窗口中使用npm安装依赖可以执行。</p><p>但是！！！</p><p>在idea中terminal使用npm<strong>报 ‘npm’不是内部或外部命令，也不是可运行的程序 或批处理文件</strong>。 </p><p>我又找到了以下解决方案：</p><p><a href="https://www.cnblogs.com/yuanchaoyong/p/12612402.html">解决方案来源</a></p><p>将shell path地址换成如下。C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe，重启idea。再试试。</p><p>按照这个方法，再可以在terminal中执行npm命令了！</p><p>我们继续执行这个：</p><pre class="line-numbers language-none"><code class="language-none">npm i -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>等待下载完成以后，继续安装vue的脚手架工具，在Terminal内继续输入以下命令</li></ul><blockquote><pre class="line-numbers language-none"><code class="language-none">npm i -g vue-cli&#96; 测试是否安装成功： &#96;vue -V<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></blockquote><h4 id="踩坑2"><a href="#踩坑2" class="headerlink" title="踩坑2"></a>踩坑2</h4><p><a href="https://blog.csdn.net/qq_32068809/article/details/79512709">解决方案来源</a></p><p>我们需要使用npm安装vue，在执行了上面的命令时，报错如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">C:\Users\lxz&gt;npm uninstall vueWcspnpm WARN saveError ENOENT: no such file or directory, open &#39;C:\Users\lxz\package.json&#39;npm WARN enoent ENOENT: no such file or directory, open &#39;C:\Users\lxz\package.json&#39;npm WARN lxz No descriptionnpm WARN lxz No repository field.npm WARN lxz No README datanpm WARN lxz No license field.up to date in 0.765s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>根据错误提示，是系统没有‘package.json’这个文件导致。这个文件的作用就是管理你本地安装的npm包，一个package.json文件可以做如下事情：</p><blockquote><p>展示项目所依赖的npm包<br>允许你指定一个包的版本[范围]<br>让你建立起稳定，意味着你可以更好的与其他开发者共享</p></blockquote><p>此刻我们需要执行命令：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html">npm init<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>创建package.json文件，系统会提示相关配置，也可以使用命令：</p><pre class="line-numbers language-html" data-language="html"><code class="language-html">npm init -y<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>直接创建package.json文件，这样创建好处是必填项已经帮你填好，执行完命令后可以看到用户路径下多了一个package.json文件。</p><p>踩完坑，我们继续！！！</p><ul><li>脚手架安装完成后，初始化包结构,继续输入</li></ul><blockquote><pre class="line-numbers language-none"><code class="language-none">vue init webpack demo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><ul><li>demo为你前面新建的项目名。初始化会进行设置。可参考此处设置。</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/11582167-40136051e9fe8657.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/903" alt="img"></p><h4 id="ps1"><a href="#ps1" class="headerlink" title="ps1."></a>ps1.</h4><p>在使用 <strong>vue-cli</strong> 脚手架构建项目时，会遇到一个构建选项 <strong>Vue build</strong>，有两个选项，<strong>Runtime + Compiler</strong>和<strong>Runtime-only：</strong></p><p>关于这两种的选择可参考：<a href="https://blog.csdn.net/qq_40938301/article/details/104357910">优质文章</a></p><p><strong>· Runtime + Compiler: recommended for most users</strong></p><p>（运行程序+编译器:推荐给大多数用户）</p><p><strong>· Runtime-only: about 6KB lighter min+gzip, but templates (or any Vue-specificHTML) are ONLY allowed in .vue files - render functions are required elsewhere</strong></p><p>（仅运行程序: 比上面那种模式轻大约 6KB min+gzip，但是 template (或任何特定于vue的html)只允许在.vue文件中使用——其他地方用需要 render 函数）</p><h4 id="ps2"><a href="#ps2" class="headerlink" title="ps2."></a>ps2.</h4><p>对于这样有选项的，可以用 下 方向键选择，选中后回车即可！（不要像我傻傻 的不知所措）</p><p>继续！！！</p><ul><li><p>初始化完成后。依次在Terminal输入图片内的黄色文字</p></li><li><p>demo为你前面新建的项目名；第二句括号中的不用输，我就是傻傻的输入了。。</p></li></ul><ul><li>完成后，会提示在哪个端口可以访问，此处现在是8080</li></ul><ul><li>打开浏览器输入：localhost:8080,出现以下画面，简单的demo就搭建完成了 。</li></ul><p>此时，我们就可以新建Vue Component了！</p><p>创建成功！回去继续上狂神的Vue去了…</p><p>本文的主要步骤参考自：</p><p>作者：不爱编程的程序员<br>链接：<a href="https://www.jianshu.com/p/9c1d4f8ed068">https://www.jianshu.com/p/9c1d4f8ed068</a><br>来源：简书</p><p>期间加入了个人所遇到的一些问题及对应的解决方案，希望能给大家带来帮助！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;IDEA中从零开始创建Vue项目&quot;&gt;&lt;a href=&quot;#IDEA中从零开始创建Vue项目&quot; class=&quot;headerlink&quot; title=&quot;IDEA中从零开始创建Vue项目&quot;&gt;&lt;/a&gt;IDEA中从零开始创建Vue项目&lt;/h1&gt;&lt;p&gt;好久没学技术了，今天开始学习</summary>
      
    
    
    
    <category term="技术" scheme="http://localhost:4000/InitiativeYu.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="VUE" scheme="http://localhost:4000/InitiativeYu.github.io/tags/VUE/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://localhost:4000/InitiativeYu.github.io/2021/02/16/helloworld/"/>
    <id>http://localhost:4000/InitiativeYu.github.io/2021/02/16/helloworld/</id>
    <published>2021-02-16T06:22:36.234Z</published>
    <updated>2021-03-02T08:52:37.854Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new &quot;My New Post&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    <category term="生活" scheme="http://localhost:4000/InitiativeYu.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="hexo" scheme="http://localhost:4000/InitiativeYu.github.io/tags/hexo/"/>
    
  </entry>
  
</feed>
